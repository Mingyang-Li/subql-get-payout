# The root query type which gives access points into the data universe.
type Query implements Node {
  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  nodeId: ID!

  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    nodeId: ID!
  ): Node

  # Reads and enables pagination through a set of `Account`.
  accounts(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Account`.
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]

    # A filter to be used in determining which values should be returned by the collection.
    filter: AccountFilter
  ): AccountsConnection

  # Reads and enables pagination through a set of `Subquery`.
  subqueries(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Subquery`.
    orderBy: [SubqueriesOrderBy!] = [PRIMARY_KEY_ASC]

    # A filter to be used in determining which values should be returned by the collection.
    filter: SubqueryFilter
  ): SubqueriesConnection

  # Reads and enables pagination through a set of `Transfer`.
  transfers(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Transfer`.
    orderBy: [TransfersOrderBy!] = [PRIMARY_KEY_ASC]

    # A filter to be used in determining which values should be returned by the collection.
    filter: TransferFilter
  ): TransfersConnection
  account(id: String!): Account
  subquery(id: Int!): Subquery
  subqueryByName(name: String!): Subquery
  transfer(id: String!): Transfer

  # Reads a single `Account` using its globally unique `ID`.
  accountByNodeId(
    # The globally unique `ID` to be used in selecting a single `Account`.
    nodeId: ID!
  ): Account

  # Reads a single `Subquery` using its globally unique `ID`.
  subqueryByNodeId(
    # The globally unique `ID` to be used in selecting a single `Subquery`.
    nodeId: ID!
  ): Subquery

  # Reads a single `Transfer` using its globally unique `ID`.
  transferByNodeId(
    # The globally unique `ID` to be used in selecting a single `Transfer`.
    nodeId: ID!
  ): Transfer
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
}

# A connection to a list of `Account` values.
type AccountsConnection {
  # A list of `Account` objects.
  nodes: [Account]!

  # A list of edges which contains the `Account` and cursor to aid in pagination.
  edges: [AccountsEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Account` you could get from the connection.
  totalCount: Int!
}

type Account implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: String!
  createdAt: Datetime!
  updatedAt: Datetime!

  # Reads and enables pagination through a set of `Transfer`.
  recievedTransfers(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Transfer`.
    orderBy: [TransfersOrderBy!] = [PRIMARY_KEY_ASC]

    # A filter to be used in determining which values should be returned by the collection.
    filter: TransferFilter
  ): TransfersConnection!

  # Reads and enables pagination through a set of `Transfer`.
  sentTransfers(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Transfer`.
    orderBy: [TransfersOrderBy!] = [PRIMARY_KEY_ASC]

    # A filter to be used in determining which values should be returned by the collection.
    filter: TransferFilter
  ): TransfersConnection!

  # Reads and enables pagination through a set of `Account`.
  accountsByTransferToIdAndFromId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Account`.
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]

    # A filter to be used in determining which values should be returned by the collection.
    filter: AccountFilter
  ): AccountAccountsByTransferToIdAndFromIdManyToManyConnection!

  # Reads and enables pagination through a set of `Account`.
  accountsByTransferFromIdAndToId(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Account`.
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]

    # A filter to be used in determining which values should be returned by the collection.
    filter: AccountFilter
  ): AccountAccountsByTransferFromIdAndToIdManyToManyConnection!
}

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

# A connection to a list of `Transfer` values.
type TransfersConnection {
  # A list of `Transfer` objects.
  nodes: [Transfer]!

  # A list of edges which contains the `Transfer` and cursor to aid in pagination.
  edges: [TransfersEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Transfer` you could get from the connection.
  totalCount: Int!
}

type Transfer implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: String!
  amount: BigFloat
  toId: String!
  fromId: String!
  createdAt: Datetime!
  updatedAt: Datetime!

  # Reads a single `Account` that is related to this `Transfer`.
  to: Account

  # Reads a single `Account` that is related to this `Transfer`.
  from: Account
}

# A floating point number that requires more precision than IEEE 754 binary 64
scalar BigFloat

# A `Transfer` edge in the connection.
type TransfersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Transfer` at the end of the edge.
  node: Transfer
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

# Methods to use when ordering `Transfer`.
enum TransfersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  TO_ID_ASC
  TO_ID_DESC
  FROM_ID_ASC
  FROM_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A filter to be used against `Transfer` object types. All fields are combined with a logical ‘and.’
input TransferFilter {
  # Filter by the object’s `id` field.
  id: StringFilter

  # Filter by the object’s `amount` field.
  amount: BigFloatFilter

  # Filter by the object’s `toId` field.
  toId: StringFilter

  # Filter by the object’s `fromId` field.
  fromId: StringFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [TransferFilter!]

  # Checks for any expressions in this list.
  or: [TransferFilter!]

  # Negates the expression.
  not: TransferFilter
}

# A filter to be used against String fields. All fields are combined with a logical ‘and.’
input StringFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: String

  # Not equal to the specified value.
  notEqualTo: String

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: String

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: String

  # Included in the specified list.
  in: [String!]

  # Not included in the specified list.
  notIn: [String!]

  # Less than the specified value.
  lessThan: String

  # Less than or equal to the specified value.
  lessThanOrEqualTo: String

  # Greater than the specified value.
  greaterThan: String

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: String

  # Contains the specified string (case-sensitive).
  includes: String

  # Does not contain the specified string (case-sensitive).
  notIncludes: String

  # Contains the specified string (case-insensitive).
  includesInsensitive: String

  # Does not contain the specified string (case-insensitive).
  notIncludesInsensitive: String

  # Starts with the specified string (case-sensitive).
  startsWith: String

  # Does not start with the specified string (case-sensitive).
  notStartsWith: String

  # Starts with the specified string (case-insensitive).
  startsWithInsensitive: String

  # Does not start with the specified string (case-insensitive).
  notStartsWithInsensitive: String

  # Ends with the specified string (case-sensitive).
  endsWith: String

  # Does not end with the specified string (case-sensitive).
  notEndsWith: String

  # Ends with the specified string (case-insensitive).
  endsWithInsensitive: String

  # Does not end with the specified string (case-insensitive).
  notEndsWithInsensitive: String

  # Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  like: String

  # Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  notLike: String

  # Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  likeInsensitive: String

  # Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  notLikeInsensitive: String

  # Equal to the specified value (case-insensitive).
  equalToInsensitive: String

  # Not equal to the specified value (case-insensitive).
  notEqualToInsensitive: String

  # Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  distinctFromInsensitive: String

  # Equal to the specified value, treating null like an ordinary value (case-insensitive).
  notDistinctFromInsensitive: String

  # Included in the specified list (case-insensitive).
  inInsensitive: [String!]

  # Not included in the specified list (case-insensitive).
  notInInsensitive: [String!]

  # Less than the specified value (case-insensitive).
  lessThanInsensitive: String

  # Less than or equal to the specified value (case-insensitive).
  lessThanOrEqualToInsensitive: String

  # Greater than the specified value (case-insensitive).
  greaterThanInsensitive: String

  # Greater than or equal to the specified value (case-insensitive).
  greaterThanOrEqualToInsensitive: String
}

# A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’
input BigFloatFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: BigFloat

  # Not equal to the specified value.
  notEqualTo: BigFloat

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: BigFloat

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: BigFloat

  # Included in the specified list.
  in: [BigFloat!]

  # Not included in the specified list.
  notIn: [BigFloat!]

  # Less than the specified value.
  lessThan: BigFloat

  # Less than or equal to the specified value.
  lessThanOrEqualTo: BigFloat

  # Greater than the specified value.
  greaterThan: BigFloat

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: BigFloat
}

# A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
input DatetimeFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: Datetime

  # Not equal to the specified value.
  notEqualTo: Datetime

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: Datetime

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: Datetime

  # Included in the specified list.
  in: [Datetime!]

  # Not included in the specified list.
  notIn: [Datetime!]

  # Less than the specified value.
  lessThan: Datetime

  # Less than or equal to the specified value.
  lessThanOrEqualTo: Datetime

  # Greater than the specified value.
  greaterThan: Datetime

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: Datetime
}

# A connection to a list of `Account` values, with data from `Transfer`.
type AccountAccountsByTransferToIdAndFromIdManyToManyConnection {
  # A list of `Account` objects.
  nodes: [Account]!

  # A list of edges which contains the `Account`, info from the `Transfer`, and the cursor to aid in pagination.
  edges: [AccountAccountsByTransferToIdAndFromIdManyToManyEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Account` you could get from the connection.
  totalCount: Int!
}

# A `Account` edge in the connection, with data from `Transfer`.
type AccountAccountsByTransferToIdAndFromIdManyToManyEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Account` at the end of the edge.
  node: Account

  # Reads and enables pagination through a set of `Transfer`.
  sentTransfers(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Transfer`.
    orderBy: [TransfersOrderBy!] = [PRIMARY_KEY_ASC]

    # A filter to be used in determining which values should be returned by the collection.
    filter: TransferFilter
  ): TransfersConnection!
}

# Methods to use when ordering `Account`.
enum AccountsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A filter to be used against `Account` object types. All fields are combined with a logical ‘and.’
input AccountFilter {
  # Filter by the object’s `id` field.
  id: StringFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [AccountFilter!]

  # Checks for any expressions in this list.
  or: [AccountFilter!]

  # Negates the expression.
  not: AccountFilter
}

# A connection to a list of `Account` values, with data from `Transfer`.
type AccountAccountsByTransferFromIdAndToIdManyToManyConnection {
  # A list of `Account` objects.
  nodes: [Account]!

  # A list of edges which contains the `Account`, info from the `Transfer`, and the cursor to aid in pagination.
  edges: [AccountAccountsByTransferFromIdAndToIdManyToManyEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Account` you could get from the connection.
  totalCount: Int!
}

# A `Account` edge in the connection, with data from `Transfer`.
type AccountAccountsByTransferFromIdAndToIdManyToManyEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Account` at the end of the edge.
  node: Account

  # Reads and enables pagination through a set of `Transfer`.
  recievedTransfers(
    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # The method to use when ordering `Transfer`.
    orderBy: [TransfersOrderBy!] = [PRIMARY_KEY_ASC]

    # A filter to be used in determining which values should be returned by the collection.
    filter: TransferFilter
  ): TransfersConnection!
}

# A `Account` edge in the connection.
type AccountsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Account` at the end of the edge.
  node: Account
}

# A connection to a list of `Subquery` values.
type SubqueriesConnection {
  # A list of `Subquery` objects.
  nodes: [Subquery]!

  # A list of edges which contains the `Subquery` and cursor to aid in pagination.
  edges: [SubqueriesEdge!]!

  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Subquery` you could get from the connection.
  totalCount: Int!
}

type Subquery implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String!
  dbSchema: String!
  version: Int!
  hash: String!
  nextBlockHeight: Int!
  network: String
  networkGenesis: String
  createdAt: Datetime!
  updatedAt: Datetime!
}

# A `Subquery` edge in the connection.
type SubqueriesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Subquery` at the end of the edge.
  node: Subquery
}

# Methods to use when ordering `Subquery`.
enum SubqueriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DB_SCHEMA_ASC
  DB_SCHEMA_DESC
  VERSION_ASC
  VERSION_DESC
  HASH_ASC
  HASH_DESC
  NEXT_BLOCK_HEIGHT_ASC
  NEXT_BLOCK_HEIGHT_DESC
  NETWORK_ASC
  NETWORK_DESC
  NETWORK_GENESIS_ASC
  NETWORK_GENESIS_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

# A filter to be used against `Subquery` object types. All fields are combined with a logical ‘and.’
input SubqueryFilter {
  # Filter by the object’s `id` field.
  id: IntFilter

  # Filter by the object’s `name` field.
  name: StringFilter

  # Filter by the object’s `dbSchema` field.
  dbSchema: StringFilter

  # Filter by the object’s `version` field.
  version: IntFilter

  # Filter by the object’s `hash` field.
  hash: StringFilter

  # Filter by the object’s `nextBlockHeight` field.
  nextBlockHeight: IntFilter

  # Filter by the object’s `network` field.
  network: StringFilter

  # Filter by the object’s `networkGenesis` field.
  networkGenesis: StringFilter

  # Filter by the object’s `createdAt` field.
  createdAt: DatetimeFilter

  # Filter by the object’s `updatedAt` field.
  updatedAt: DatetimeFilter

  # Checks for all expressions in this list.
  and: [SubqueryFilter!]

  # Checks for any expressions in this list.
  or: [SubqueryFilter!]

  # Negates the expression.
  not: SubqueryFilter
}

# A filter to be used against Int fields. All fields are combined with a logical ‘and.’
input IntFilter {
  # Is null (if `true` is specified) or is not null (if `false` is specified).
  isNull: Boolean

  # Equal to the specified value.
  equalTo: Int

  # Not equal to the specified value.
  notEqualTo: Int

  # Not equal to the specified value, treating null like an ordinary value.
  distinctFrom: Int

  # Equal to the specified value, treating null like an ordinary value.
  notDistinctFrom: Int

  # Included in the specified list.
  in: [Int!]

  # Not included in the specified list.
  notIn: [Int!]

  # Less than the specified value.
  lessThan: Int

  # Less than or equal to the specified value.
  lessThanOrEqualTo: Int

  # Greater than the specified value.
  greaterThan: Int

  # Greater than or equal to the specified value.
  greaterThanOrEqualTo: Int
}
